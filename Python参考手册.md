# Python参考手册 #
### 三、数据模型 ###
#### 3.1 对象，值和类型 ####
*对象*是Python数据的抽象。Python程序中所有数据都是以对像或者对象之间关系的形式呈现。（从某种意义上说，为了契合冯 诺伊曼计算机模型，代码也是对象。）  
所有对象都具有标识，类型和值。对象一旦创建它的标识就不会改变;你可以标识想象为对象在内存中对地址。* 'is' *操作符对比两个对象的标识，** id() **函数返回一个代表标识号的整数（目前来说是它的地址）。对象的* 类型 *也是不可变的。对象的类型决定对象支持的运算（比如，是否有长度），同时也定义了这个类型可能对值。** type() **函数返回对象的类型（也就是对象本身）。一部分对象的值可以改变。如果对象的值可以改变我们称为可变对象， 如果一经赋值不可改变是不可变对象。（不可变容器对象的值包含可变对象时，不可变容器对值随可变对象的值改变而改变;尽管容器仍然是不可变的，因为它所包含的对象集合不可改变。所以，很微妙，不可变对象并不是值完全不可变化。）对象的可变性由它的类型决定;例如，数字，字符串和元祖是不可变的，字典和列表是可变的。  
对象不会显式的摧毁，尽管，如果它们变成不可用对象后可能会被当成垃圾数据回收。一种实现允许被延迟回收或者集体删除--这取决于垃圾回收机制的实现方法，可用对象不会被回收。  
** CPython实现细节: ** CPython目前使用一种延迟检测循环依赖的引用计数垃圾回收结构，它会在立刻收集不可用对象，但是不会主动回收仍然带有循环依赖的垃圾。阅读文档中gc模块中关于循环引用垃圾控制的信息。Python的其他i实现方式的垃圾回收机制不同，CPython也可能会改变。在对象不可用后不要依赖于立即终结。  
使用追踪和排虫功能可以使对象可以被收集还能保持可用性。同时注意使用 * try...except * 结构获取到异常后对象仍然可用。  
一些调用额外资源的对象比如打开文件或者窗口。对象被回收后它们的资源被释放，但是垃圾回收机制并不鼓励发生，这样的对象也提供了显式方法释放额外资源，通常是 ** close() ** 方法。程序强烈建议显式关闭e这样的对象。** try...finally **   语句提供一个方便的方法来达到目的。  
一些对象包含其他对象的引用;这些对象被称为容器。元祖，列表和字典是容器的例子。这些引用是容器值的一部分。大多数情况下，当我们说容器值的时候，我们暗指值，不是内部对象的标识;尽管我们谈论容器的可变性时，只表示内部不可变对象的标识。所以一个不可变对象包含可变对象的引用，当可变对象改变的时候它的值也改变了。  
类型影响对象行为的方方面面。某种意义上，对象特性的重要性也可以被影响:对于不可变类型，计算一个新值也许是引用一个已经存在的相同值和类型的对象，对于可变对象不允许这样。例如，** a = 1 ** ;** b=1 **,** a **和** b **会或者不会指向同一个值为一的对象，依赖于程序的实现;但是** c = [] **;** d = [] **，** c **和** d **指向两个不同的新创建的空表。（注意** c = d = [] **将同一个对象赋给** c **和** d **。）  
#### 3.2 标准类型层级  ####
下边列出Python的内建类型。扩展模块（使用C,Java,或者其他语言编写，依赖于实现方式）定义附加类型。未来Python也许会增加更多的类型（比如，有理数，有效率的整数向量）  
下边叙述的一些类型中包含一段被称为'特殊属性'的段落。这些属性针对CPython实现，并不是所有实现都有。这些属性在未来可能会发生变化。  
** None ** 这个类型是单值类型。这个值有一个唯一对象。通过内置名称None可以访问这个对象。在很多情况下利用这个类型来标识缺少值。例如，当函数不需要显式的返回任何值的时候返回None。它的真值为false。  
** NotImplemented **这个类型是个单值类型。这个值有一个唯一对象。通过内置名称NotImplemented访问这个对象。如果数字方法和富比较方法没有实现在操作数中实现这个操作方法，会返回这个值，(The interpreter will then try
the reflected operation, or some other fallback, depending on the operator.)它的真值为true。  
** Ellipsis **这个类型是一个单值类型。这个值有一个唯一对象。通过内置名称Ellipsis访问这个对象。它用来指示片段中的...语句。它的真值为true。  
** numbers.Number **这个类型通过数值型文本创建作为算数运算和内置算数函数的结果返回。数值对象是不可变的，一旦创建 不会改变。Python数字与数学数字强相关，但是对象受限于它在电脑中的实现。  
Python中数字分为整数，浮点数和复数：  
** numbers.Integral **这个类型表示数学上的整数（正数和负数）  
有三种类型的整数：  
&nbsp;&nbsp;** 普通整数 **表示范围为-2147483648到2147483648范围内的数字。（这个范围在电脑上可能会更大，但是不会变小）如果操作结果超过这个数字会自动转化为长类型整数（一些情况下会抛出* overflowError *异常）。为了移位和掩码运算，整数使用32位或更多位二进制补位并且不对用户隐藏（所有4294967296个比特位组合对应不同值）。  
&nbsp;&nbsp; ** 长整数 ** 长整数对数值范围没有限制，只要有足够的内存（虚拟内存）。对于移位和掩码运算，长整数使用二进制，负数使用二进制补码，给人一种符号位向左无限扩展的字符串。  
&nbsp;&nbsp; ** 布尔值 ** 布尔值表示真值的真或者假。False和True是布尔对象唯一的两个值。布尔类是普通整数的子类，布尔值在几乎所有环境中类似于0和1.，例外的情况就是返回字符串的时候返回"False"和"True"字符串。  
整数的表示规则是为了使负数的移位和掩码运算更有意义，并且使普通整数和长整数在转换的时候有最少的意外。对于任何运算，如果它产生的结果是普通整数域中，那么长整数或混合运算时产生相同的结果。域转换对程序员是透明的。  
** numbers.Real(float) ** 机器级双位精确度浮点数。可接受的范围和溢出控制依赖于底层机器结构（和C或者Java实现）。Python不支持单精度浮点数，使用两种精确度浮点数的原因通常是为了节省处理器和内存的使用，但是相对于Python对象的开销这些是微不足道的，因此没必要支持两种精确度的浮点数使语言变复杂。  
** numbers.Complex ** 复数使用一对机器级双精度浮点数表示。单精度浮点数同样可以表示复数。复数z的实部和虚部可以通过只读属性z.real和z.imag获得。  
  
** 序列 **   这种类型表示有限非负索引顺序集合。内建函数len()返回序列元素个数。当一个序列的长度为 * n * 时，索引集合包含的数字为 0, 1, ..., n-1。序列a中的第i个元素通过a[i]选择。  
序列也支持切片操作：a[i:j]选择索引K满足 * i < = k < j * 的所有元素。当作为表达式使用时，切片是相同类型的序列。  
一些序列使用第三个“步长”参数的“扩展切片”：a[i:j:k]选择a中所有索引为x的元素，x = i + n*k，n>=0且i <= x < j 。  
  
序列依据他们的可变性可分为：  
  
** 不可变序列 ** 不可变类型的对象一旦创建不能更改。（如果不可变对象引用其他对象，如果其他对象是可变的并且改变了，这个不可变对象直接引用的对象集合不可改变。）  

接来的这些类型是不可变序列：  
  
  ** 字符串 ** 字符串由字符组成。没有单独的字符类型，字符是由含有一个元素的字符串表示。字符以（至少）8比特字节表示。内建函数 chr() 和 ord()可以在字符和表示字符值的非负整数之间转换。 字节通常使用0-127表示相应的ASCII值，但是对于这些值的解释由程序决定。字符串数据类型也用来表示字节数组，例如保存文件中读取的数据。  
  （在系统中原生字符集不是ASCII的系统上，字符串在内部使用EBCDIC表示，使用char()和ord()函数实现ASCII和EBCDIC的 映射，并保持字符串的使用ASCII顺序。或许有人可以提出更好的规则？）  
  ** Unicode ** Unicode对象的元素是Unicode编码单元。一个Unicode编码单元由一个元素的Unicode对象表示并使用一个16位或者32位的值表示一个Unicode序数（序数的最大值在sys.maxunicode中给出，并依赖于Python在编译时如何配置的）。Unicode 对象中可以表示代理对，并被当作两个单独的元素。内建的函数unichr() 和ord()在编码单元和表示定义在Unicode 标准3.0中Unicode 序数的非负整数之间转换。和其它编码之间相互转换可以通过Unicode 方法encode() 和内建的函数unicode()。  
  ** 元祖 ** 元组的元素可以是Python中的任何对象。两个或更多元素组成的元组由逗号分隔的一连串表达式形成。一个元素的元组可以在表达式后添加一个逗号构成（一个表达式不能构成元组，必须有括号组合起这些表达式）。空元组由括号对构成。  
  ** 可变序列 ** 可变序列可以在创建后改变。下标和切片可以使用赋值和del语句。  
  
  下边是两种内建可变序列类：   
      ** 列表 **  列表的元素可以使Python的任何对象。列表由在方括号中被逗号分隔的一连串表达式构成。（注意长度为0或1的列表没有特殊的规定）
      ** 字节数组 ** 一个字节数组对象是一个可变数组。它由内建函数bytearray()构造函数创建。除了可变性（不可哈希），字节数组提供和不可变对象同样的接口和函数。  
      array扩展模块提供了另外一个可变序列对象的例子。
  