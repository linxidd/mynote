# Python参考手册 #
## 三、数据模型 ##
### 3.1 对象，值和类型 ###
*对象*是Python数据的抽象。Python程序中所有数据都是以对像或者对象之间关系的形式呈现。（从某种意义上说，为了契合冯 诺伊曼计算机模型，代码也是对象。）  
所有对象都具有标识，类型和值。对象一旦创建它的标识就不会改变;你可以标识想象为对象在内存中对地址。* 'is' *操作符对比两个对象的标识，** id() **函数返回一个代表标识号的整数（目前来说是它的地址）。对象的* 类型 *也是不可变的。对象的类型决定对象支持的运算（比如，是否有长度），同时也定义了这个类型可能对值。** type() **函数返回对象的类型（也就是对象本身）。一部分对象的值可以改变。如果对象的值可以改变我们称为可变对象， 如果一经赋值不可改变是不可变对象。（不可变容器对象的值包含可变对象时，不可变容器对值随可变对象的值改变而改变;尽管容器仍然是不可变的，因为它所包含的对象集合不可改变。所以，很微妙，不可变对象并不是值完全不可变化。）对象的可变性由它的类型决定;例如，数字，字符串和元祖是不可变的，字典和列表是可变的。  
对象不会显式的摧毁，尽管，如果它们变成不可用对象后可能会被当成垃圾数据回收。一种实现允许被延迟回收或者集体删除--这取决于垃圾回收机制的实现方法，可用对象不会被回收。  
** CPython实现细节: ** CPython目前使用一种延迟检测循环依赖的引用计数垃圾回收结构，它会在立刻收集不可用对象，但是不会主动回收仍然带有循环依赖的垃圾。阅读文档中gc模块中关于循环引用垃圾控制的信息。Python的其他i实现方式的垃圾回收机制不同，CPython也可能会改变。在对象不可用后不要依赖于立即终结。  
使用追踪和排虫功能可以使对象可以被收集还能保持可用性。同时注意使用 * try...except * 结构获取到异常后对象仍然可用。  
一些调用额外资源的对象比如打开文件或者窗口。对象被回收后它们的资源被释放，但是垃圾回收机制并不鼓励发生，这样的对象也提供了显式方法释放额外资源，通常是 ** close() ** 方法。程序强烈建议显式关闭e这样的对象。** try...finally **   语句提供一个方便的方法来达到目的。  
一些对象包含其他对象的引用;这些对象被称为容器。元祖，列表和字典是容器的例子。这些引用是容器值的一部分。大多数情况下，当我们说容器值的时候，我们暗指值，不是内部对象的标识;尽管我们谈论容器的可变性时，只表示内部不可变对象的标识。所以一个不可变对象包含可变对象的引用，当可变对象改变的时候它的值也改变了。  
类型影响对象行为的方方面面。某种意义上，对象特性的重要性也可以被影响:对于不可变类型，计算一个新值也许是引用一个已经存在的相同值和类型的对象，对于可变对象不允许这样。例如，** a = 1 ** ;** b=1 **,** a **和** b **会或者不会指向同一个值为一的对象，依赖于程序的实现;但是** c = [] **;** d = [] **，** c **和** d **指向两个不同的新创建的空表。（注意** c = d = [] **将同一个对象赋给** c **和** d **。）  
#### 3.2 标准类型层级  ####
下边列出Python的内建类型。扩展模块（使用C,Java,或者其他语言编写，依赖于实现方式）定义附加类型。未来Python也许会增加更多的类型（比如，有理数，有效率的整数向量）  
下边叙述的一些类型中包含一段被称为'特殊属性'的段落。这些属性针对CPython实现，并不是所有实现都有。这些属性在未来可能会发生变化。  
** None ** 这个类型是单值类型。这个值有一个唯一对象。通过内置名称None可以访问这个对象。在很多情况下利用这个类型来标识缺少值。例如，当函数不需要显式的返回任何值的时候返回None。它的真值为false。  
** NotImplemented **这个类型是个单值类型。这个值有一个唯一对象。通过内置名称NotImplemented访问这个对象。如果数字方法和富比较方法没有实现在操作数中实现这个操作方法，会返回这个值，(The interpreter will then try
the reflected operation, or some other fallback, depending on the operator.)它的真值为true。  
** Ellipsis **这个类型是一个单值类型。这个值有一个唯一对象。通过内置名称Ellipsis访问这个对象。它用来指示片段中的...语句。它的真值为true。  
** numbers.Number **这个类型通过数值型文本创建作为算数运算和内置算数函数的结果返回。数值对象是不可变的，一旦创建 不会改变。Python数字与数学数字强相关，但是对象受限于它在电脑中的实现。  
Python中数字分为整数，浮点数和复数：  
** numbers.Integral **这个类型表示数学上的整数（正数和负数）  
有三种类型的整数：  
&nbsp;&nbsp;** 普通整数 **表示范围为-2147483648到2147483648范围内的数字。（这个范围在电脑上可能会更大，但是不会变小）如果操作结果超过这个数字会自动转化为长类型整数（一些情况下会抛出* overflowError *异常）。为了移位和掩码运算，整数使用32位或更多位二进制补位并且不对用户隐藏（所有4294967296个比特位组合对应不同值）。  
&nbsp;&nbsp; ** 长整数 ** 长整数对数值范围没有限制，只要有足够的内存（虚拟内存）。对于移位和掩码运算，长整数使用二进制，负数使用二进制补码，给人一种符号位向左无限扩展的字符串。  
&nbsp;&nbsp; ** 布尔值 ** 布尔值表示真值的真或者假。False和True是布尔对象唯一的两个值。布尔类是普通整数的子类，布尔值在几乎所有环境中类似于0和1.，例外的情况就是返回字符串的时候返回"False"和"True"字符串。  
整数的表示规则是为了使负数的移位和掩码运算更有意义，并且使普通整数和长整数在转换的时候有最少的意外。对于任何运算，如果它产生的结果是普通整数域中，那么长整数或混合运算时产生相同的结果。域转换对程序员是透明的。  
** numbers.Real(float) ** 机器级双位精确度浮点数。可接受的范围和溢出控制依赖于底层机器结构（和C或者Java实现）。Python不支持单精度浮点数，使用两种精确度浮点数的原因通常是为了节省处理器和内存的使用，但是相对于Python对象的开销这些是微不足道的，因此没必要支持两种精确度的浮点数使语言变复杂。  
** numbers.Complex ** 复数使用一对机器级双精度浮点数表示。单精度浮点数同样可以表示复数。复数z的实部和虚部可以通过只读属性z.real和z.imag获得。  
  
** 序列 **   这种类型表示有限非负索引顺序集合。内建函数len()返回序列元素个数。当一个序列的长度为 * n * 时，索引集合包含的数字为 0, 1, ..., n-1。序列a中的第i个元素通过a[i]选择。  
序列也支持切片操作：a[i:j]选择索引K满足 * i < = k < j * 的所有元素。当作为表达式使用时，切片是相同类型的序列。  
一些序列使用第三个“步长”参数的“扩展切片”：a[i:j:k]选择a中所有索引为x的元素，x = i + n*k，n>=0且i <= x < j 。  
  
序列依据他们的可变性可分为：  
  
** 不可变序列 ** 不可变类型的对象一旦创建不能更改。（如果不可变对象引用其他对象，如果其他对象是可变的并且改变了，这个不可变对象直接引用的对象集合不可改变。）  

接来的这些类型是不可变序列：  
  
  ** 字符串 ** 字符串由字符组成。没有单独的字符类型，字符是由含有一个元素的字符串表示。字符以（至少）8比特字节表示。内建函数 chr() 和 ord()可以在字符和表示字符值的非负整数之间转换。 字节通常使用0-127表示相应的ASCII值，但是对于这些值的解释由程序决定。字符串数据类型也用来表示字节数组，例如保存文件中读取的数据。  
  （在系统中原生字符集不是ASCII的系统上，字符串在内部使用EBCDIC表示，使用char()和ord()函数实现ASCII和EBCDIC的 映射，并保持字符串的使用ASCII顺序。或许有人可以提出更好的规则？）  
  ** Unicode ** Unicode对象的元素是Unicode编码单元。一个Unicode编码单元由一个元素的Unicode对象表示并使用一个16位或者32位的值表示一个Unicode序数（序数的最大值在sys.maxunicode中给出，并依赖于Python在编译时如何配置的）。Unicode 对象中可以表示代理对，并被当作两个单独的元素。内建的函数unichr() 和ord()在编码单元和表示定义在Unicode 标准3.0中Unicode 序数的非负整数之间转换。和其它编码之间相互转换可以通过Unicode 方法encode() 和内建的函数unicode()。  
  ** 元祖 ** 元组的元素可以是Python中的任何对象。两个或更多元素组成的元组由逗号分隔的一连串表达式形成。一个元素的元组可以在表达式后添加一个逗号构成（一个表达式不能构成元组，必须有括号组合起这些表达式）。空元组由括号对构成。  
  ** 可变序列 ** 可变序列可以在创建后改变。下标和切片可以使用赋值和del语句。  
  
  下边是两种内建可变序列类：   
      ** 列表 **  列表的元素可以使Python的任何对象。列表由在方括号中被逗号分隔的一连串表达式构成。（注意长度为0或1的列表没有特殊的规定）  
      ** 字节数组 ** 一个字节数组对象是一个可变数组。它由内建函数bytearray()构造函数创建。除了可变性（不可哈希），字节数组提供和不可变对象同样的接口和函数。  
      array扩展模块提供了另外一个可变序列对象的例子。  
 ##### 集合对象 #####
这个类型表示无序的，有限的集合，集合中的元素是唯一的，不可变的对象。正因如此，它们不能任何下标索引。尽管它们可以迭代，内建函数len()可以返回集合元素的个数。集合常见的用途有快速成员关系检测，从序列中删除重复元素和计算数学运算例如交集，并集，差集和对称差集。
集合中的元素和字典的键一样遵守不可变规则。注意，数值类型遵循普通数值对比规则，如果两个数字相同（比如1和1.0），同一个集合中只能出现一个。  

这里有两个内建集合类型：  

** 集合 ** 这个类型表示可变集合。他们使用内建set()构造器创建，创建后可以使用多种方法修改，比如add()。  
** 固定集合 ** 这个类型表示不可变集合。他们使用内建构造器frozenset()构造器创建。因为固定集合不可改变且可哈希化，他可以作为其他集合的元素或者作为字典的键。  

##### 映射 
这个类型表示可以由任意索引集合索引的有限集合对象.下标表示a[k]选择映射a中由k索引的元素；它可以在表达式中使用或者作为del语句的目标。  
目前只有一种内建映射类型：  
** 字典 ** 这个类型表示几乎可以由任意值索引的有限集合对象。唯一不能作为键的是包含列表、字典或其他可变类型的值，因为这些类型的值可直接比较，而不是通过对象标示比较。这么做的原因是为了实现一个高效的字典需要键的哈希值保持不变。数值类型键允许数值比较的一般规则：如果两个数值相同（比如1和1.0）他们可以索引相同字典实体。  
字典是可变的，他们可以使用{...}方法创建。（参考Dicionary displays 章节）  
扩展模块dbm，gdbm和bsddb提供额外的映射类型的例子。  

##### 可调用对象 
这些是可以使用函数调用操作的类型：  
** 用户定义函数 ** 用户定义函数是由函数定义创建。调用时传入和形式参数列表相同个数的参数列表。  
特殊属性:  
\__doc\__ func_doc  函数的文档字符串或者None如果没有  可写  
\__name\__ func_doc    函数名    可写  
\__module\__  函数定义所在的模块或者None如果没有  可写  
\__defaults\__ func_defaults 包含有默认值参数的值的元组，如果没有参数有默认值为None。  可写
\__code\__ func_code 编译后的函数代码对象。 可写  
\__global\__ func_globals 保存函数全局变量的字典引用--定义函数的模块中的全局命名空间   只读  
\__dict\__ func_dict 允许任意函数属性的命名空间  可写  
\__closure\__ func_closure None或者包含函数自由变量绑定的元组  只读  
大部分标记可写的属性会检查赋值类型。  
** 用户定义方法 **   
用户定义方法对象将类、类实例（或None）和任何可调用对象（一般是用户定义函数）连接起来。  
特殊的只读属性： im_self 类实例对象，im_func函数对象，im_class对绑定方法指im_self的类或对未绑定方法指方法所在类；\__doc\__是方法的文档（与im_func.\__doc\__相同），\__name\__是方法的名字（与im_func.\__name\__相同）,\__module\__是方法定义所在的模块名，如果没有则为NOne。  
方法也支持访问（但不能设置）底层函数对象的任何函数属性。  
用户定义方法可以在获取类的一个属性（也许是类的实例）的时候被创建，如果那个属性是用户定义函数对象、一个未绑定的用户方法对象或者一个类的方法对象。如果属性是用户定义方法对象，那么只有类和存储在原始方法对象中的类相同或者是其子类，才会创建一个新的方法对象，否则使用原始的方法对象。  
当用户定义方法对象通过从类中获取用户定义函数对象的方法创建，他的im_self属性为None，这个方法对象我们成为未绑定。如果是通过某个实例的用户定义函数对象创建，它的im_self属性就是这个实例，我们称这个对象为绑定的。任何一种情况下，新方法的im_class属性为那个类，它的im_func属性为原始函数对象。  
如果用户定义方法对象通过类或实例的另一个方法对象创建，新的实例的im_func属性不是原始方法对象而是它的im_func属性，除此之外其行为和处理函数对象时一样。  
如果用户定义方法通过类或实例中的类方法对象创建，它的im_self属性为类本身，它的im_func属性为类方法底层的函数对象。  
当调用一个未绑定的用户定义方法对象时，调用的是底层函数（im_func)，有一个限制是第一个参数必须为合适类（im_class）或其子类的实例。  
当调用一个绑定的用户定义方法对象时，调用的是底层函数（im_func)，同时在参数列表的前边插入类的实例（im_self)。例如，当C是一个类，包含函数f()的定义，x是C的实例，调用x.f(1)就等同于C.f(x,1)。  
当用户定义方法对象是继承自一个类方法对象，im_self中的“类实例”实际上是类本身，因此用x.f(1)或者C.f(1)等同与调用f(C.1)，f是底层函数。  
注意，从函数对象到（绑定或未绑定）方法对象的转换每当从类或实例中获取属性时都会发生。一些情况下，一个好的优化将属性赋值给一个局部变量，然后调用那个局部变量。同时注意，这个转化只有用户定义的函数会发生，其他的可调用对象（和所有不可调用对象）在获取的时候不会转换。如果用户定义的函数是类实例的属性不会被转换为绑定的方法，这种转换只发生在函数是类的属性的时候。  
** 生成器函数 ** 使用* yield *语句的函数或方法成为生成器函数。调用这个函数的时候总是返回一个迭代器对象来执行函数主体：调用迭代器的next()方法使函数执行直到yield语句返回一个值。当函数执行一个return语句或到达结束位置，会引发一个StopIteration异常且迭代器会到达被返回值集合对象的尾部。  
** 内建函数 ** 内建函数对象是对C函数的封装。 内建函数的例子有len()和math.sin()（math是标准库）。参数的数量和类型由C函数决定。特殊的只读属性：\__doc\__使函数的文档字符串或者使None如果不存在；\__name\__是函数名；\__self\__被设置为None（但是看下一个元素）；\__module\__是创建函数的模块名如果没有是None。  
** 内建方法 ** 实际上它是披着马甲的内建函数，这次包含一个对象传递给C函数作为隐式参数。一个内建方法的例子使alist.append()，假设alist是一个列表对象。这种情况下，特殊的只读属性\__self\__被设置为表示alist的对象。  
** 经典类 ** 下边讲述下类对象。当调用一个类对象时，一个类实例（下边讲述）会被创建和返回。这会隐式的调用\__init\__()方法如果有的话。任何参数都会传递给\__init\__()方法。如果没有\__init\__()方法，调用这个类的时候不能含有参数。  
** 类实例 ** 下边讲述类实例。只有类中含有\__call\__()方法的时候类实例是可调用的；x(arguments）是x.\__call\__(arguments)的简写。  
** 模块 ** 模块使用import语句导入（参考import语句模块）。模块对象有一个字典对象实现的命名空间（这个字典被定义在模块中函数的func_globals属性引用）属性的引用转换为了在字典中查询,如m.x等同于m.\__dict\__["x"]。模块对象不包含初始化模块对象的代码对象（其实一旦初始化玩车的那个就不需要他们了）。  
属性复制会更新模块命名空间字典，如m.x = 1等于m.\__dict\__["x"] = 1。  
特殊只读属性：\__dict\__()是模块字典对象形式的命名空间。  
> CPython实现细节：因为CPython的模块字典清理方式，如果模块离开作用域的时候即使模块字典任然被引用也会被清除。为了避免这种情况，复制一份模块字典或者直接使用字典时保留着。   

预定义（可写）属性：\__name\__是模块名；\__doc\__是模块的文档字符串如果没有为None;\__file\__是加载模块的文件的路径如果模块是从文件中加载的话。C模块没有\__file\__属性，他们静态的链接到解释器；对于从共享库中动态加载的模块，它的路径是共享库的路径。  






